# 数据标注平台架构设计文档

## 整体架构选型

### 架构模式：前后端分离 + 微服务架构

考虑到项目的特殊需求，采用以下架构特点：
- **前后端分离**：支持多端访问，便于团队并行开发
- **微服务化**：核心功能模块化，便于扩展和维护
- **事件驱动**：支持实时协作和进度同步
- **文件服务独立**：处理大量文件操作

## 技术栈设计

### 前端技术栈

#### 核心框架
```
React 18 + TypeScript
├── 状态管理: Redux Toolkit + RTK Query
├── 路由管理: React Router v6
├── UI框架: Ant Design v5
├── 样式方案: Tailwind CSS + CSS Modules
└── 构建工具: Vite
```

#### 关键依赖
```typescript
// 数据处理
"@reduxjs/toolkit": "^1.9.0"        // 状态管理
"react-query": "^3.39.0"            // 服务端状态管理

// UI组件
"antd": "^5.0.0"                     // UI组件库
"@ant-design/pro-components": "^2.0.0" // 高级组件
"react-dnd": "^16.0.0"               // 拖拽功能

// 文件处理
"pdfjs-dist": "^3.0.0"               // PDF预览
"@monaco-editor/react": "^4.4.0"     // 代码编辑器
"react-image-gallery": "^1.2.0"      // 图片预览
"react-markdown": "^8.0.0"           // Markdown渲染

// 实时通信
"socket.io-client": "^4.6.0"         // WebSocket客户端

// 工具库
"lodash-es": "^4.17.0"               // 工具函数
"dayjs": "^1.11.0"                   // 日期处理
"file-saver": "^2.0.0"               // 文件下载
```

#### 项目结构
```
src/
├── components/           # 通用组件
│   ├── DataRenderer/    # 数据渲染组件
│   ├── AnnotationForm/  # 标注表单组件
│   ├── FileViewer/      # 文件预览组件
│   └── ProgressBar/     # 进度条组件
├── pages/               # 页面组件
│   ├── TaskConfig/      # 任务配置页
│   ├── Annotation/      # 标注页面
│   └── Dashboard/       # 管理面板
├── store/               # 状态管理
├── services/            # API服务
├── hooks/               # 自定义Hooks
├── utils/               # 工具函数
└── types/               # TypeScript类型定义
```

### 后端技术栈

#### 核心框架
```
FastAPI + Python 3.11
├── 异步处理: asyncio + aiofiles
├── 数据库: PostgreSQL + SQLAlchemy 2.0
├── 缓存: Redis
├── 任务队列: Celery + Redis
└── 消息队列: RabbitMQ
```

#### 关键依赖
```python
# Web框架
fastapi==0.104.0              # 主框架
uvicorn[standard]==0.24.0     # ASGI服务器
pydantic==2.5.0               # 数据验证

# 数据库
sqlalchemy[asyncio]==2.0.0    # ORM
asyncpg==0.29.0               # PostgreSQL驱动
alembic==1.13.0               # 数据库迁移

# 任务队列
celery[redis]==5.3.0          # 任务队列
redis==5.0.0                  # 缓存和消息代理

# 文件处理
aiofiles==23.2.0              # 异步文件操作
PyPDF2==3.0.0                 # PDF处理
Pillow==10.1.0                # 图片处理
openpyxl==3.1.0               # Excel处理

# 实时通信
python-socketio==5.10.0       # WebSocket服务端

# 工具库
python-multipart==0.0.6       # 文件上传
python-jose[cryptography]==3.3.0  # JWT处理
passlib[bcrypt]==1.7.0        # 密码加密
```

#### 微服务划分
```
services/
├── auth_service/         # 认证服务
├── task_service/         # 任务管理服务
├── file_service/         # 文件处理服务
├── annotation_service/   # 标注服务
├── notification_service/ # 通知服务
└── export_service/       # 导出服务
```

## 核心模块设计

### 1. 前端核心模块

#### 1.1 数据渲染引擎 (DataRenderer)
```typescript
interface DataRendererProps {
  fieldConfig: FieldConfig;
  data: any;
}

// 支持的数据类型
enum DataType {
  TEXT = 'text',
  IMAGE = 'image',
  CODE = 'code',
  PDF = 'pdf',
  MARKDOWN = 'markdown'
}

// 渲染器工厂
class RendererFactory {
  static create(type: DataType): BaseRenderer {
    switch(type) {
      case DataType.TEXT: return new TextRenderer();
      case DataType.IMAGE: return new ImageRenderer();
      case DataType.CODE: return new CodeRenderer();
      case DataType.PDF: return new PDFRenderer();
      default: return new TextRenderer();
    }
  }
}
```

#### 1.2 动态表单引擎 (AnnotationForm)
```typescript
interface AnnotationConfig {
  type: 'radio' | 'checkbox' | 'input' | 'rating';
  options?: string[];
  validation?: ValidationRule[];
  dependencies?: FormDependency[];
}

// 表单生成器
class FormGenerator {
  generateForm(config: AnnotationConfig[]): JSX.Element {
    return config.map(item => {
      return FormFactory.create(item.type, item);
    });
  }
}
```

#### 1.3 实时同步模块 (RealtimeSync)
```typescript
class RealtimeSync {
  private socket: Socket;
  
  constructor() {
    this.socket = io(process.env.REACT_APP_WS_URL);
    this.setupEventListeners();
  }
  
  private setupEventListeners() {
    this.socket.on('progress_update', this.handleProgressUpdate);
    this.socket.on('task_assigned', this.handleTaskAssigned);
  }
}
```

### 2. 后端核心模块

#### 2.1 任务管理服务 (TaskService)
```python
# app/services/task_service.py
class TaskService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_task(self, task_data: TaskCreate) -> Task:
        # 创建任务
        task = Task(**task_data.dict())
        self.db.add(task)
        await self.db.commit()
        
        # 异步处理数据分片
        distribute_data.delay(task.id)
        return task
    
    async def distribute_data(self, task_id: str, annotator_count: int):
        # 数据分片算法
        pass
```

#### 2.2 文件处理服务 (FileService)
```python
# app/services/file_service.py
class FileService:
    def __init__(self):
        self.storage_path = settings.FILE_STORAGE_PATH
    
    async def upload_file(self, file: UploadFile) -> FileInfo:
        # 文件验证
        await self.validate_file(file)
        
        # 保存文件
        file_path = await self.save_file(file)
        
        # 解析JSONL
        if file.filename.endswith('.jsonl'):
            await self.parse_jsonl.delay(file_path)
        
        return FileInfo(path=file_path, size=file.size)
    
    async def parse_jsonl(self, file_path: str):
        # 异步解析JSONL文件
        pass
```

#### 2.3 标注服务 (AnnotationService)
```python
# app/services/annotation_service.py
class AnnotationService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.redis = Redis()
    
    async def save_annotation(self, annotation_data: AnnotationCreate):
        # 保存标注结果
        annotation = Annotation(**annotation_data.dict())
        self.db.add(annotation)
        
        # 更新进度缓存
        await self.update_progress_cache(annotation.task_id)
        
        # 发送实时更新
        await self.broadcast_progress(annotation.task_id)
```

## 数据流设计

### API 接口规范

#### 1. RESTful API 设计
```python
# 任务管理API
POST   /api/v1/tasks              # 创建任务
GET    /api/v1/tasks              # 获取任务列表
GET    /api/v1/tasks/{task_id}    # 获取任务详情
PUT    /api/v1/tasks/{task_id}    # 更新任务
DELETE /api/v1/tasks/{task_id}    # 删除任务

# 文件管理API
POST   /api/v1/files              # 上传文件
GET    /api/v1/files/{file_id}    # 获取文件信息
GET    /api/v1/files/{file_id}/content  # 获取文件内容

# 标注API
POST   /api/v1/annotations        # 提交标注
GET    /api/v1/annotations        # 获取标注列表
PUT    /api/v1/annotations/{id}   # 更新标注

# 导出API
POST   /api/v1/exports            # 创建导出任务
GET    /api/v1/exports/{export_id}/download  # 下载导出文件
```

#### 2. WebSocket 事件设计
```typescript
// 客户端 -> 服务端
interface ClientEvents {
  join_task: (taskId: string) => void;
  annotation_update: (data: AnnotationData) => void;
  request_progress: (taskId: string) => void;
}

// 服务端 -> 客户端
interface ServerEvents {
  progress_update: (data: ProgressData) => void;
  task_assigned: (data: TaskAssignment) => void;
  annotation_conflict: (data: ConflictData) => void;
}
```

### 数据模型设计

#### 1. 数据库模型
```python
# models/task.py
class Task(Base):
    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    description = Column(Text)
    config = Column(JSON)  # 任务配置
    status = Column(Enum(TaskStatus))
    created_by = Column(String, ForeignKey('users.id'))
    created_at = Column(DateTime)
    
    # 关联关系
    annotations = relationship('Annotation', back_populates='task')
    assignments = relationship('TaskAssignment', back_populates='task')

# models/annotation.py
class Annotation(Base):
    id = Column(String, primary_key=True)
    task_id = Column(String, ForeignKey('tasks.id'))
    data_index = Column(Integer)  # 数据条目索引
    result = Column(JSON)  # 标注结果
    status = Column(Enum(AnnotationStatus))
    annotator_id = Column(String, ForeignKey('users.id'))
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
```

#### 2. 前端状态模型
```typescript
// store/taskSlice.ts
interface TaskState {
  currentTask: Task | null;
  taskList: Task[];
  loading: boolean;
  error: string | null;
}

// store/annotationSlice.ts
interface AnnotationState {
  currentData: DataItem | null;
  annotations: Record<string, any>;
  progress: ProgressInfo;
  config: AnnotationConfig;
}
```

## 关键交互流程

### 1. 任务创建流程
```mermaid
sequenceDiagram
    participant U as 用户
    participant F as 前端
    participant T as 任务服务
    participant FS as 文件服务
    participant Q as 任务队列
    
    U->>F: 上传JSONL文件
    F->>FS: POST /api/v1/files
    FS->>Q: 解析文件任务
    FS->>F: 返回文件信息
    
    U->>F: 配置标注任务
    F->>T: POST /api/v1/tasks
    T->>Q: 数据分片任务
    T->>F: 返回任务信息
```

### 2. 标注操作流程
```mermaid
sequenceDiagram
    participant A as 标注员
    participant F as 前端
    participant AS as 标注服务
    participant WS as WebSocket
    participant R as Redis
    
    A->>F: 提交标注
    F->>AS: POST /api/v1/annotations
    AS->>R: 更新进度缓存
    AS->>WS: 广播进度更新
    WS->>F: progress_update事件
    F->>A: 界面更新
```

## 部署架构

### 容器化部署
```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://api:8000
  
  api:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/db
      - REDIS_URL=redis://redis:6379
  
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=annotation_platform
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7
    volumes:
      - redis_data:/data
  
  celery:
    build: ./backend
    command: celery -A app.celery worker --loglevel=info
    depends_on:
      - redis
      - postgres
```

### 扩展性设计
1. **水平扩展**：通过负载均衡器支持多实例部署
2. **数据库分片**：按任务ID进行数据分片
3. **文件存储**：使用对象存储服务(如MinIO)
4. **缓存策略**：Redis集群支持高并发访问

这个架构设计充分考虑了项目的特殊需求，你觉得哪个部分需要进一步讨论或调整？
